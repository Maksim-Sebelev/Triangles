# Треугольники
## Автор проекта: Себелев Максим

# Зависимости:

У проекта **НЕТ обязательных зависимостей** для его обычной работы. Зависимости есть для unit-тестирования, об этом читайте далее.\
Однако для удобной работы понадобятся следующие инструменты:


## Для комплиляции:
[clang++](https://clang.org/)\
[g++](https://gcc.gnu.org/)


## Для сборки:
[cmake](https://cmake.org/ "ссылка на официальный сайт cmake")\
[ninja](https://ninja-build.org "ссылка на оффициальный сайт ninja")\
`Ninja` рекомендуется для данного проекта, так как в большистве пакетных менеджеров поставляется версия, для которой `cmake` умеет работать с модулями (`.cppm`).

## Требования:
`clang++` - **18.0+**\
`g++`     - **15.0+**\
`cmake`   - **3.28+**\
`ninja`   - **1.11.1+**\
<br>
*в `start.sh` будет явно указываться clang++ как комплилятор, потому что clang меньше всего подвержен багам с модулями, как показал мой личный опыт*

## Для unit-тестирования (автоматическая установка с помощью `cmake`):
[googletest](https://github.com/google/googletest "ссылка на официльный репозиторий googletest")

## Для скачивания проекта:
[git](https://git-scm.com/ "ссылка на официальный сайт git")

# Установка:
```bash
git clone --recurse-submodules https://github.com/Maksim-Sebelev/Triangles.git
cd Triangles
```

# Если Ваше устройство поддерживает `bash` или `zsh`
*Наверняка, если у Вас Linux - то у вас поддерживается `bash`*

# Если вы категорически НЕ согласны со стилем оформлением кода автора:
Предоставлен скрипт `format.sh` который вызывает `clang-format` для всех необходимых файлов проекта. Подключайте свой любимый конфиг или оставьте настройки по умолчанию и **наслаждайтесь** табами в 2 пробела и { без переноса на следующую строку (без негатива):
```bash
bash format.sh
```
или:
```bash
zsh format.sh
```

# Сборка проекта:
В таком случае можете просто выполнить:
```bash
bash start.sh
```
или если вы хотите пользоваться логгером (зачем то):
```bash
bash start.sh use-logger
```
или (например на `macOS`):
```bash
zsh start.sh
# или
zsh start.sh use-logger
```

*Подробнее про логгер можно прочиать в его официльном [репозитории](https://github.com/Maksim-Sebelev/logger.git) или `README.md` по относительному пути `./Src/third-party/logger/README.md`.*

Данный скрипт устанавливает необходимые зависимоти и собирает проект с помощью `cmake`.\
Скрипт выведет информацию, если что-то пойдет не так.\
После перейдите в папку `build`:
```bash
cd build/
```
и теперь можете начинать работать с проектом.\
Дальнейшие инструкции по установке Вам читать и выполнять **НЕ** нужно, можете переходить к изучению сути проекта :)

# Если у Вас **НЕ** поддерживается `bash` :
# Сборка и компиляция:
```bash
cmake -S Src -B build -DCMAKE_BUILD_TYPE=Release -G "Ninja"
cmake --build build
cd build
```
<br>
<br> 
<br>

# Структура проекта:
```txt
..
├── assets
│   ├── bug-on-clang.png
│   └── bug-on-gcc.png
├── start.sh
├── format.sh
├── README.md
├── Src
│   ├── CMakeLists.txt
│   ├── include
│   │   ├── create_run_program_file
│   │   │   └── cringe
│   │   │       └── create_run_program_file.hpp
│   │   ├── geometry
│   │   │   ├── constants.hpp
│   │   │   └── relative_positions.hpp
│   │   └── global
│   │       ├── custom_console_output.hpp
│   │       └── global.hpp
│   ├── modules
│   │   ├── geometry
│   │   │   ├── line.cppm
│   │   │   ├── plain.cppm
│   │   │   ├── point.cppm
│   │   │   └── triangle.cppm
│   │   ├── math
│   │   │   ├── compare.cppm
│   │   │   ├── linear_systems.cppm
│   │   │   ├── matrix.cppm
│   │   │   └── vector.cppm
│   │   └── test
│   │       ├── execute_test
│   │       │   └── execute_test.cppm
│   │       ├── flag_parse
│   │       │   ├── flag_parser.cppm
│   │       │   └── input_stream.cppm
│   │       ├── global
│   │       │   └── test_files.cppm
│   │       ├── parse_result
│   │       │   └── parse_test_result.cppm
│   │       └── read_input
│   │           ├── get_test_data.cppm
│   │           ├── read_test_answer.cppm
│   │           └── read_test_data.cppm
│   ├── src
│   │   ├── run_double_triangles.cpp
│   │   └── run_float_triangles.cpp
│   └── third-party
│       └── logger
│           ├── README.md
│           ├── Src
│           │   ├── CMakeLists.txt
│           │   ├── include
│           │   │   ├── global
│           │   │   │   ├── console_custom_output.hpp
│           │   │   │   └── global.hpp
│           │   │   └── logger
│           │   │       └── log_background_settings.hpp
│           │   └── modules
│           │       └── log.cppm
│           ├── start.sh
│           └── tests
│               └── test.cpp
└── tests
    ├── ans
    │   ├── 1.ans
    │   ├── 2.ans
    │   ├── 3.ans
    │   └── 4.ans
    ├── dat
    │   ├── 1.dat
    │   ├── 2.dat
    │   ├── 3.dat
    │   └── 4.dat
    └── unit-tests
        ├── geometry
        │   ├── unit_test_line.cpp
        │   ├── unit_test_plain.cpp
        │   ├── unit_test_point.cpp
        │   └── unit_test_triangles.cpp
        ├── math
        │   ├── unit_test_compare.cpp
        │   ├── unit_test_linear_system.cpp
        │   ├── unit_test_matrix.cpp
        │   └── unit_test_vector.cpp
        └── test
            ├── unit_test_flag_parser.cpp
            ├── unit_test_get_test_data.cpp
            ├── unit_test_read_answer.cpp
            └── unit_test_read_test_data.cpp

33 directories, 57 files
```

# Что из себя представляет проект?
## Цель проекта:
Проект реализован под вполне конкретную задачу:\
На вход подается число `N`, после чего идет описание `N` треугольников в 3-мерном евклидовом пространстве. А на выходе ожидаются номера тех треугольников, которые пересекаются с камим-либо другим из данного списка.

## Формат входных данных:
Опишем более подробно, как задается треугольник:
```txt
<первая вершина> <вторая вершина> <третья вершина>
```
Хорошо, а как задается вершина? - как точка в 3-мерном евклидовом пространстве:
```txt
<x координата> <y координата> <z координата>
```
Сами координаты имеют НЕ целочисленный тип. В программе используется `float`, но благодаря
```cpp
using coordinate_t = float;
```
Легко все переделать на `double`, если Вы хотите **пожертвовать** скоростью ради точности.\

Подведем итог: пусть мы хотим считать треугольник `ABC` со следующих данных:
```bash
1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0
```
Тогда:\
вершина `A` будет иметь координаты `(1.0, 2.0, 3.0)`\
вершина `B` будет иметь координаты `(4.0, 5.0, 6.0)`\
вершина `C` будет иметь координаты `(7.0, 8.0, 9.0)`\

Теперь мы готовы осознать общий формат ввода:
```bash
3 # количество треугольников => ожидается 9*3=27 чисел на вводе
1.0  2.0  3.0 # первая вершина первого  треугольника
4.0  5.0  6.0 # вторая вершина первого  треугольника
7.0  8.0  9.0 # третья вершина первого  треугольника
10.0 11.0 12.0 # первая вершина второго  треугольника
13.0 14.0 15.0 # вторая вершина второго  треугольника
16.0 17.0 18.0 # третья вершина второго  треугольника
19.0 20.0 21.0 # первая вершина третьего треугольника
22.0 23.0 24.0 # вторая вершина третьего треугольника
25.0 26.0 27.0 # третья вершина третьего треугольника
```
*числа подобны для просты понимания. вполне могут быть другие числа, и не обязтаельно .0*

## Формат выходных данных:
Программа возвращает номера тех треугольников, которые имеют пересечесение хотя-бы с одним треугольником из того же списка (*пересечения с самим собой, очевидно, не учитываются*). Причем номера идут в **отсортированном по возрастанию порядке**.


## Форматы ввода-вывода:
Программа имеет опцию `--input_sream` и ее короткую версию `-i`, которая имеет 2 значения: `stdin` и `files`, где `stdin` является значением по умолчанию. Это значит, что без явного указания программа ожидает данные с `stdin`.\
Разберем на примерах (команды выполняются из папки `build/`):
```bash
./run_triangles                      # ожидает данные с stdin, и выведет результат в stdout
./run_triangles --input_stream=stdin # ожидает данные с stdin, и выведет результат в stdout
./run_triangles -istdin              # ожидает данные с stdin, и выведет результат в stdout
```
Если же вы укажете значение `files`, то в качестве аргументов должны передать пути до файлов, откуда будут браться данные.\
**ВАЖНО**:\
1) Данная опция предусматривалась исключительно для тестирования программы.
2) В силу `1)`, программа ожидает так же получить файл с правильным ответом. Будут сравниваться полученные в результате работы программы данные и данные из файла с ответом. Если они равные, программа сделать `return 0`, иначе `return 1` и выведет соотвественную информацию о результате тестирования.
3) Тестовые данные подаются только в `.dat` файлах. Иные расширения приниматься не будут.
4) Ответы подаются только в `.ans` файлах.
5) Нельзя определять файлы до явно указания `--input_stream=stdin`

<br>

Разбереме на примерах (команды выполняются из папки `build/`):
```bash
./run_triangles --input_stream=files test.dat test.ans # тестовые данные из test.dat, ответ из test.ans, на выход подается инфофрмация о результатах тестирования
./run_triangles -ifiles              test.dat test.ans # тестовые данные из test.dat, ответ из test.ans, на выход подается инфофрмация о результатах тестирования
```



# Тестирование программы:
В директории `./tests` есть 3 поддиректории: `dat`, `ans`, `unit-tests`:
```bash
tests
    ├── ans
    │   ├── 1.ans
    │   ├── 2.ans
    │   ├── 3.ans
    │   └── 4.ans
    ├── dat
    │   ├── 1.dat
    │   ├── 2.dat
    │   ├── 3.dat
    │   └── 4.dat
    └── unit-tests
        ├── geometry
        │   ├── unit_test_line.cpp
        │   ├── unit_test_plain.cpp
        │   ├── unit_test_point.cpp
        │   └── unit_test_triangles.cpp
        ├── math
        │   ├── unit_test_compare.cpp
        │   ├── unit_test_linear_system.cpp
        │   ├── unit_test_matrix.cpp
        │   └── unit_test_vector.cpp
        └── test
            ├── unit_test_flag_parser.cpp
            ├── unit_test_get_test_data.cpp
            ├── unit_test_read_answer.cpp
            └── unit_test_read_test_data.cpp
```

Для unit-тестирования используется `googletest` (он был установлен когда вы запускали `cmake`).\
Все модули программы проходят unit-тестирования. Вот так выглядит папка для тестирования:
```bash
unit-tests
        ├── geometry
        │   ├── unit_test_line.cpp
        │   ├── unit_test_plain.cpp
        │   ├── unit_test_point.cpp
        │   └── unit_test_triangles.cpp
        ├── math
        │   ├── unit_test_compare.cpp
        │   ├── unit_test_linear_system.cpp
        │   ├── unit_test_matrix.cpp
        │   └── unit_test_vector.cpp
        └── test
            ├── unit_test_flag_parser.cpp
            ├── unit_test_get_test_data.cpp
            ├── unit_test_read_answer.cpp
            └── unit_test_read_test_data.cpp
```

Так же есть тесты имитирующие полную работу программы. Для этого в папках `./tests/dat/` и `./tests/ans/` хранятся файлы с тестовыми данными и правильными ответами соотвественно.\

Для компиляции тестов выполните:
```bash
ninja ready_for_unit_tests
```
После чего запустите тесты:
```bash
ctest
```
Или для подробного вывода:
```bash
ctest --verbose
```

<br>

# Главный алгоритм:
Сразу о печальном, программа реализует алгоритм, асимптотическая сложность которого есть `O(n`<sup>`2`</sup>`)`, что безусловно долго (я уже в курсе об окто-дереве, но пока его я не реализовал).\
Главный класс, реализованный в проекте:
```cpp
template <typename coordinate_t> class triangle_t;
```
имеет метод:
```cpp
bool is_intersect_with_another_triangle(const triangle_t& triangle);
```
*(его асимтотическая сложность `O(1)`)*\
И работа прогаммы есть попарное пересечение треугольников. Отсюда и `n`<sup>`2`</sup>.\
Сам же принцип работы метода довольно прост:\
Если треугольники лежат в разных плоскостях, то рассматривается линия пересеченяия эти плоскостей. Она пересекается с каждым треугольником (это пересечение либо пустое множество, либо точка, либо отрезок). И далее проверяется пересекаются ли эти самые отрезки пересечения между собой. Если да - то треугольники пересекаются, в противном случае - нет.\
Если же треугольники лежат в одной плоскости, то ищутся попарные пересечения между сторонами треугольников. Если хотя бы 1 пара пересекается, то и треугольники тоже, иначе - нет.

<br>

# Проблемы проекта:
1) Асимптотическая сложность алгоритма, но об этом я уже сказал.
2) Плохая работа с погрешностями вычисления floating-point чисел. Везде допустимая погрешность взята случайно, как просто достаточно маленькое число (`1e-2` - `1e-6`), из-за чего могут быть возникать проблемы с ложными пересечениями.



# Рофлы:
Я словил баги сразу на 2 компиляторах:\
**Приношу извинения за качество**
![сломал шланг](./assets/bug-on-clang.png)
![сломал гцц](./assets//bug-on-gcc.png)
